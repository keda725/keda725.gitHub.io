<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Do Some Great!</title>
        <link>https://keda725.github.io/posts/</link>
        <description>Recent content in Posts on Do Some Great!</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-Hans</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Mon, 10 Aug 2020 14:24:45 +0800</lastBuildDate>
        <atom:link href="https://keda725.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Java基础之方法 变量</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%B9%E6%B3%95-%E5%8F%98%E9%87%8F/</link>
            <pubDate>Mon, 10 Aug 2020 14:24:45 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%B9%E6%B3%95-%E5%8F%98%E9%87%8F/</guid>
            <description>一、方法  方法：语句的集合，他们一起执行一个功能  方法是解决一类问题的步骤的有序集合 方法包含在类或者对象中 方法在程序中被创建 在其它地方被引用  二、构造器 构造器：   package com.github.zuojiabin; public class Main { public static void main(String[] args) { Cat cat = new Cat(); cat.name = &amp;#34;喵&amp;#34;; Cat cat1 = new Cat(&amp;#34;喵喵&amp;#34;); } }   package com.github.zuojiabin; public class Cat { //成员变量  public String name; //静态成员变量 不和任何对象相绑定  //static int i  //假如没有声明任何的constructor 构造器  //编译器会自动帮你生成一个  // &amp;lt;init&amp;gt;  //Cat() {}  //假如你写了下面的有参数的构造方法 那编译器就不会帮你生成，并且在你创建cat实例的时候  //如果你没有传入参数的时候 编译器会报错  public Cat() { } public Cat(String name){ this.</description>
            <content type="html"><![CDATA[<h3 id="一方法">一、方法</h3>
<hr>
<h4 id="方法语句的集合他们一起执行一个功能">方法：语句的集合，他们一起执行一个功能</h4>
<ul>
<li>方法是解决一类问题的步骤的有序集合</li>
<li>方法包含在类或者对象中</li>
<li>方法在程序中被创建 在其它地方被引用</li>
</ul>
<h3 id="二构造器">二、构造器</h3>
<h4 id="构造器">构造器：</h4>
<ul>
<li>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.github.zuojiabin<span style="color:#f92672">;</span>
  
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Cat cat <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Cat<span style="color:#f92672">();</span>
    cat<span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;喵&#34;</span><span style="color:#f92672">;</span>
      
    Cat cat1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Cat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;喵喵&#34;</span><span style="color:#f92672">);</span>
      
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.github.zuojiabin<span style="color:#f92672">;</span>
  
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">//成员变量
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> String name<span style="color:#f92672">;</span>
    
  <span style="color:#75715e">//静态成员变量   不和任何对象相绑定
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//static int i
</span><span style="color:#75715e"></span>    
    
  <span style="color:#75715e">//假如没有声明任何的constructor 构造器
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//编译器会自动帮你生成一个
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// &lt;init&gt;
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//Cat() {}
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//假如你写了下面的有参数的构造方法 那编译器就不会帮你生成，并且在你创建cat实例的时候
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//如果你没有传入参数的时候 编译器会报错
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Cat</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> 
  <span style="color:#f92672">}</span>
    
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Cat</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">){</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
    
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">meow</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h3 id="三实例方法">三、实例方法</h3>
<h4 id="实例方法类方法实例方法和类方法也分别称为非静态方法和静态方法">实例方法/类方法：实例方法和类方法也分别称为非静态方法和静态方法。</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//静态方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doRightMethod</span><span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
<span style="color:#75715e">//非静态方法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doBadMethod</span><span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
</code></pre></div><ul>
<li>
<p>调用类的静态方法时，这个类的实例可能不存在，因此不允许与从静态方法内部引用实例变量</p>
<ul>
<li>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.github.zuojiabin<span style="color:#f92672">;</span>
    
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> String name<span style="color:#f92672">;</span>
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Cat</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> 
  <span style="color:#f92672">}</span>
      
  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Cat</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">){</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>
      
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">meow</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;喵喵喵，我是&#34;</span> <span style="color:#f92672">+</span> name<span style="color:#f92672">);</span> <span style="color:#75715e">//name会报错
</span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="四变量">四、变量</h3>
<h4 id="局部变量">局部变量：</h4>
<ul>
<li>在每次函数调用的时候有效 函数结束就销毁了</li>
<li>声明在方法 构造方法 或者语句块中</li>
<li>访问修饰符不能用于局部变量</li>
<li>只在声明它的方法 构造函数 或者语句块中可见</li>
<li>是在栈上分配的 存在于遥远的jvm中</li>
<li>没有默认值 在声明后 必须经过初始化 才能使用</li>
</ul>
<h4 id="静态成员变量">静态成员变量：</h4>
<ul>
<li>声明在类中，方法体之外，但是必须声明为static类型 是类的成员 会持续存在</li>
</ul>
<h4 id="成员变量">成员变量：</h4>
<ul>
<li>定义在类中，方法体之外的变量，该变量在创建对象的时候被初始化，成员变量可以被类中的方法、构造方法和特定类的语句块访问。</li>
</ul>
<h4 id="静态成员变量和成员变量的区别">静态成员变量和成员变量的区别：</h4>
<ul>
<li><strong>静态成员变量有static关键字修饰</strong> 成员变量没有                 &mdash;定义</li>
<li><strong>静态成员变量可以通过类名.成员变量名直接访问</strong>  一般成员变量需要通过对象.一半成员变量名访问     &mdash;使用</li>
<li><strong>Java虚拟机加载类的过程中会为静态成员变量分配内存</strong>  一半成员变量是在Java虚拟机创建一个实例，为每个实例分配一块内存               &mdash;初始化</li>
<li><strong>静态成员变量被类的所有实例所共享</strong>一般成员变量取决于每个实例                    &mdash;所属范围</li>
<li><strong>静态成员变量位于方法区</strong>  一般成员变量位于堆内存                             &mdash;内存分布</li>
<li><strong>静态成员变量取决于类的生命周期</strong>  一般成员变量取决于实例的生命周期                       &mdash;生命周期</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>身边美好的风景2020/8/8</title>
            <link>https://keda725.github.io/posts/2020/08/%E8%BA%AB%E8%BE%B9%E7%BE%8E%E5%A5%BD%E7%9A%84%E9%A3%8E%E6%99%AF2020/8/8/</link>
            <pubDate>Sat, 08 Aug 2020 22:56:58 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/%E8%BA%AB%E8%BE%B9%E7%BE%8E%E5%A5%BD%E7%9A%84%E9%A3%8E%E6%99%AF2020/8/8/</guid>
            <description>哈哈 太久没怎么拍过街上的风景啦，今天也是兴趣来了拍了几张，记录一下身边美好😁
ps：确实没有挑出来很多，也就这四张比较满意🎉🎉🎉
 一个投篮机就是他们的世界
 什么时候我也能这么潮？
 办活动的小姐姐被围着一通拍～
 舞台上的人即使是黑白配色也是光彩照人
 这样的照片小集合 应该未来还有。</description>
            <content type="html"><![CDATA[<p>哈哈 太久没怎么拍过街上的风景啦，今天也是兴趣来了拍了几张，记录一下身边美好😁</p>
<p>ps：确实没有挑出来很多，也就这四张比较满意🎉🎉🎉</p>
<hr>
<p>一个投篮机就是他们的世界</p>
<p><img src="/img/%E4%BB%8A%E6%97%A5%E8%BA%AB%E8%BE%B9%E7%BE%8E%E5%A5%BD/4.0.png" alt="天真的小孩子"></p>
<hr>
<p>什么时候我也能这么潮？</p>
<p><img src="/img/%E4%BB%8A%E6%97%A5%E8%BA%AB%E8%BE%B9%E7%BE%8E%E5%A5%BD/3.0.png" alt="街头"></p>
<hr>
<p>办活动的小姐姐被围着一通拍～</p>
<p><img src="/img/%E4%BB%8A%E6%97%A5%E8%BA%AB%E8%BE%B9%E7%BE%8E%E5%A5%BD/2.0.png" alt="蹭拍"></p>
<hr>
<p>舞台上的人即使是黑白配色也是光彩照人</p>
<p><img src="/img/%E4%BB%8A%E6%97%A5%E8%BA%AB%E8%BE%B9%E7%BE%8E%E5%A5%BD/1.0.png" alt="舞台上的人"></p>
<hr>
<p>这样的照片小集合 应该未来还有。</p>
]]></content>
        </item>
        
        <item>
            <title>Java之异常体系</title>
            <link>https://keda725.github.io/posts/2020/08/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</link>
            <pubDate>Thu, 06 Aug 2020 17:08:20 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E4%B9%8B%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</guid>
            <description>异常入门与控制流 异常的类型体系 异常的栈轨迹 异常处理 </description>
            <content type="html"><![CDATA[<h4 id="异常入门与控制流">异常入门与控制流</h4>
<h4 id="异常的类型体系">异常的类型体系</h4>
<h4 id="异常的栈轨迹">异常的栈轨迹</h4>
<h4 id="异常处理">异常处理</h4>
]]></content>
        </item>
        
        <item>
            <title>Java之IO</title>
            <link>https://keda725.github.io/posts/2020/08/java%E4%B9%8Bio/</link>
            <pubDate>Thu, 06 Aug 2020 17:03:38 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E4%B9%8Bio/</guid>
            <description>计算机多级体系原理简介 文件的本质 输入 输出 Java的io 文件类File Java- nio </description>
            <content type="html"><![CDATA[<h4 id="计算机多级体系原理简介">计算机多级体系原理简介</h4>
<h4 id="文件的本质">文件的本质</h4>
<h4 id="输入-输出-java的io">输入 输出 Java的io</h4>
<h4 id="文件类file">文件类File</h4>
<h4 id="java--nio">Java- nio</h4>
]]></content>
        </item>
        
        <item>
            <title>Web前后端架构分析</title>
            <link>https://keda725.github.io/posts/2020/08/web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</link>
            <pubDate>Thu, 06 Aug 2020 16:59:38 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/web%E5%89%8D%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</guid>
            <description>计算机网络架构与HTTP原理 使用Java发起http请求 使用Java解析html提取内容 同步与异步加载 http方法和状态码 http的header和body http协议实战 </description>
            <content type="html"><![CDATA[<h4 id="计算机网络架构与http原理">计算机网络架构与HTTP原理</h4>
<h4 id="使用java发起http请求">使用Java发起http请求</h4>
<h4 id="使用java解析html提取内容">使用Java解析html提取内容</h4>
<h4 id="同步与异步加载">同步与异步加载</h4>
<h4 id="http方法和状态码">http方法和状态码</h4>
<h4 id="http的header和body">http的header和body</h4>
<h4 id="http协议实战">http协议实战</h4>
]]></content>
        </item>
        
        <item>
            <title>Collection体系原理与常用实现</title>
            <link>https://keda725.github.io/posts/2020/08/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0/</link>
            <pubDate>Thu, 06 Aug 2020 16:57:58 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/collection%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0/</guid>
            <description>Collection体系原理与常用实现 Map与常用实现 </description>
            <content type="html"><![CDATA[<h4 id="collection体系原理与常用实现">Collection体系原理与常用实现</h4>
<h4 id="map与常用实现">Map与常用实现</h4>
]]></content>
        </item>
        
        <item>
            <title>Maven包管理与maven初步</title>
            <link>https://keda725.github.io/posts/2020/08/maven%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8Emaven%E5%88%9D%E6%AD%A5/</link>
            <pubDate>Thu, 06 Aug 2020 16:55:47 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/maven%E5%8C%85%E7%AE%A1%E7%90%86%E4%B8%8Emaven%E5%88%9D%E6%AD%A5/</guid>
            <description>Java的包原理 Maven的包管理 包冲突及解决 maven的其它知识 </description>
            <content type="html"><![CDATA[<h4 id="java的包原理">Java的包原理</h4>
<h4 id="maven的包管理">Maven的包管理</h4>
<h4 id="包冲突及解决">包冲突及解决</h4>
<h4 id="maven的其它知识">maven的其它知识</h4>
]]></content>
        </item>
        
        <item>
            <title>Hugo搭建个人博客</title>
            <link>https://keda725.github.io/posts/2020/08/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
            <pubDate>Thu, 06 Aug 2020 16:54:22 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
            <description>Hugo搭建个人博客</description>
            <content type="html"><![CDATA[<p>Hugo搭建个人博客</p>
]]></content>
        </item>
        
        <item>
            <title>Git之远程仓库</title>
            <link>https://keda725.github.io/posts/2020/08/git%E4%B9%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</link>
            <pubDate>Thu, 06 Aug 2020 16:50:09 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/git%E4%B9%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</guid>
            <description>远程仓库 </description>
            <content type="html"><![CDATA[<h3 id="远程仓库">远程仓库</h3>
]]></content>
        </item>
        
        <item>
            <title>Git之本地仓库</title>
            <link>https://keda725.github.io/posts/2020/08/git%E4%B9%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</link>
            <pubDate>Thu, 06 Aug 2020 16:49:28 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/git%E4%B9%8B%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</guid>
            <description>本地仓库 </description>
            <content type="html"><![CDATA[<h3 id="本地仓库">本地仓库</h3>
]]></content>
        </item>
        
        <item>
            <title>命令行</title>
            <link>https://keda725.github.io/posts/2020/08/%E5%91%BD%E4%BB%A4%E8%A1%8C/</link>
            <pubDate>Thu, 06 Aug 2020 16:46:16 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid>
            <description>命令行 命令行的历史 命令行如何启动 工作目录和环境变量 可执行程序 参数 Linux文件权限 输入与输出 Linux常见命令详解 使用命令行编译Java程序 Java中fork子进程 </description>
            <content type="html"><![CDATA[<h3 id="命令行">命令行</h3>
<h4 id="命令行的历史">命令行的历史</h4>
<h4 id="命令行如何启动">命令行如何启动</h4>
<h4 id="工作目录和环境变量">工作目录和环境变量</h4>
<h4 id="可执行程序">可执行程序</h4>
<h4 id="参数">参数</h4>
<h4 id="linux文件权限">Linux文件权限</h4>
<h4 id="输入与输出">输入与输出</h4>
<h4 id="linux常见命令详解">Linux常见命令详解</h4>
<h4 id="使用命令行编译java程序">使用命令行编译Java程序</h4>
<h4 id="java中fork子进程">Java中fork子进程</h4>
]]></content>
        </item>
        
        <item>
            <title>Java基础（十）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%8D%81/</link>
            <pubDate>Thu, 06 Aug 2020 16:42:22 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%8D%81/</guid>
            <description>面向对象：多态 多态 策略模式 使用多态简化、重构代码 </description>
            <content type="html"><![CDATA[<h3 id="面向对象多态">面向对象：多态</h3>
<h4 id="多态">多态</h4>
<h4 id="策略模式">策略模式</h4>
<h4 id="使用多态简化重构代码">使用多态简化、重构代码</h4>
]]></content>
        </item>
        
        <item>
            <title>Java基础（九）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B9%9D/</link>
            <pubDate>Thu, 06 Aug 2020 16:38:54 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B9%9D/</guid>
            <description>面向对象：组合与继承 继承的本质是避免重复 Java继承体系与Object中的常用方法 继承中的类结构和初始化顺序 实例方法的覆盖 设计模式：模版方法 向上_向下转型 final关键字 单例模式 </description>
            <content type="html"><![CDATA[<h3 id="面向对象组合与继承">面向对象：组合与继承</h3>
<h4 id="继承的本质是避免重复">继承的本质是避免重复</h4>
<h4 id="java继承体系与object中的常用方法">Java继承体系与Object中的常用方法</h4>
<h4 id="继承中的类结构和初始化顺序">继承中的类结构和初始化顺序</h4>
<h4 id="实例方法的覆盖">实例方法的覆盖</h4>
<h4 id="设计模式模版方法">设计模式：模版方法</h4>
<h4 id="向上_向下转型">向上_向下转型</h4>
<h4 id="final关键字">final关键字</h4>
<h4 id="单例模式">单例模式</h4>
]]></content>
        </item>
        
        <item>
            <title>Java基础（八）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%85%AB/</link>
            <pubDate>Thu, 06 Aug 2020 16:37:17 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%85%AB/</guid>
            <description>Java对象系统基础 对象基本概念：成员与初始化 方法的重载 对象的初始化顺序 对象的生命周期 </description>
            <content type="html"><![CDATA[<h3 id="java对象系统基础">Java对象系统基础</h3>
<h4 id="对象基本概念成员与初始化">对象基本概念：成员与初始化</h4>
<h4 id="方法的重载">方法的重载</h4>
<h4 id="对象的初始化顺序">对象的初始化顺序</h4>
<h4 id="对象的生命周期">对象的生命周期</h4>
]]></content>
        </item>
        
        <item>
            <title>Java基础（七）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B8%83/</link>
            <pubDate>Thu, 06 Aug 2020 16:35:15 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B8%83/</guid>
            <description>Java控制流 方法的控制流 while与do-while循环 for与foreach循环 break与continue switch语句 </description>
            <content type="html"><![CDATA[<h3 id="java控制流">Java控制流</h3>
<h4 id="方法的控制流">方法的控制流</h4>
<h4 id="while与do-while循环">while与do-while循环</h4>
<h4 id="for与foreach循环">for与foreach循环</h4>
<h4 id="break与continue">break与continue</h4>
<h4 id="switch语句">switch语句</h4>
]]></content>
        </item>
        
        <item>
            <title>Java基础（六）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%85%AD/</link>
            <pubDate>Thu, 06 Aug 2020 16:33:03 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%85%AD/</guid>
            <description>Java的运算系统 基本运算符 字增自减运算符 比较运算符 逻辑运算符与短路特性 三元运算符 位运算 运算符优先级与字符串加法操作 </description>
            <content type="html"><![CDATA[<h3 id="java的运算系统">Java的运算系统</h3>
<h4 id="基本运算符">基本运算符</h4>
<h4 id="字增自减运算符">字增自减运算符</h4>
<h4 id="比较运算符">比较运算符</h4>
<h4 id="逻辑运算符与短路特性">逻辑运算符与短路特性</h4>
<h4 id="三元运算符">三元运算符</h4>
<h4 id="位运算">位运算</h4>
<h4 id="运算符优先级与字符串加法操作">运算符优先级与字符串加法操作</h4>
]]></content>
        </item>
        
        <item>
            <title>Java基础（五）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%BA%94/</link>
            <pubDate>Thu, 06 Aug 2020 16:31:52 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%BA%94/</guid>
            <description>null与equals约定在数据类型中的应用 </description>
            <content type="html"><![CDATA[<h3 id="null与equals约定在数据类型中的应用">null与equals约定在数据类型中的应用</h3>
]]></content>
        </item>
        
        <item>
            <title>Java基础（四）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</link>
            <pubDate>Thu, 06 Aug 2020 16:29:43 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</guid>
            <description>一、数据在计算机中是如何存储的？ 二、基本数据类型 三、类型转换与类型提升 四、基本数据类型对应的装箱类型 </description>
            <content type="html"><![CDATA[<h3 id="一数据在计算机中是如何存储的">一、数据在计算机中是如何存储的？</h3>
<h3 id="二基本数据类型">二、基本数据类型</h3>
<h3 id="三类型转换与类型提升">三、类型转换与类型提升</h3>
<h3 id="四基本数据类型对应的装箱类型">四、基本数据类型对应的装箱类型</h3>
]]></content>
        </item>
        
        <item>
            <title>Java基础（三）</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B8%89/</link>
            <pubDate>Thu, 06 Aug 2020 16:27:52 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B8%89/</guid>
            <description>对象与引用 方法的传值VS传引用 </description>
            <content type="html"><![CDATA[<h3 id="对象与引用">对象与引用</h3>
<h3 id="方法的传值vs传引用">方法的传值VS传引用</h3>
]]></content>
        </item>
        
        <item>
            <title>Java基础之Java的跨平台性/类/包</title>
            <link>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B9%8Bjava%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7/%E7%B1%BB/%E5%8C%85/</link>
            <pubDate>Wed, 05 Aug 2020 23:07:08 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/java%E5%9F%BA%E7%A1%80%E4%B9%8Bjava%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7/%E7%B1%BB/%E5%8C%85/</guid>
            <description>一、Java的跨平台性的一个比喻  ​	一次开发，在所有的机器上都能够跑起来，不管是Windows Linux Mac，在每个操作装有JVM虚拟机，是他帮你做了翻译的事情。
​	每个国家都有自己的语言 为了让别人听懂你讲什么 你在每个国家找了一个懂这个语言的人 你只需要发布一个说明书 每个国家看懂说明书的人 就能根据这说明书 把你的话翻译成这个国家人能听懂的语言 这个人就是JVM 说明书就是字节码(ByteCode)。
二、嘛是字节码？  ​	Java具有跨平台特性，为了实现这个特性Java执行在一台虚拟机上，这个虚拟机就是JVM，Java通过JVM屏蔽了不同平台上之间的差异，从而做到一次编译，处处执行。
​	JVM位于Java编译器和OS平台之间，Java编译器只需要面向JVM，生成JVM能够理解的代码，这个代码就是字节码，JVM再把字节码翻译成真实机器能够理解的二进制机器码。
三、Java语言的基本单元&amp;mdash;类和包  类  public class Cat { //类名是Cat  // 这就是一个类 } //class定义结束 要求：
 类名必须是英文字母开头，后接字母 数字和下划线的组合  习惯以大写字母开头   好的类命名(见名知意)  getClass(获取class) saveGithubPullRequestsToCSV(保存GitHub的pr到csv文件) isEmpty(判断是不是空)    为什么存在包这个东西？   在菜鸟网站上关于包(package)的第一句话是：
​	为了更好的组织类，Java提供了包机制，用来区别类名的命名空间。
 Java包这个机制是为了防止命名冲突，访问控制，提供搜索和定位类 接口 枚举 注释等。举个例子
package com.keda725; public class Main { } public class Main { } 这两个类的区别在于哪里？好像是没有区别，那么可以直接在同一位置创建两个这样的java文件嘛？答案是否定的，那么这实际上是怎么创建两个内容上一样的文件的呢？</description>
            <content type="html"><![CDATA[<h3 id="一java的跨平台性的一个比喻">一、Java的跨平台性的一个比喻</h3>
<hr>
<p>​		一次开发，在所有的机器上都能够跑起来，不管是Windows Linux Mac，在每个操作装有JVM虚拟机，是他帮你做了翻译的事情。</p>
<p>​		每个国家都有自己的语言 为了让别人听懂你讲什么 你在每个国家找了一个懂这个语言的人 你只需要发布一个说明书  每个国家看懂说明书的人 就能根据这说明书 把你的话翻译成这个国家人能听懂的语言  这个人就是JVM 说明书就是字节码(ByteCode)。</p>
<h3 id="二嘛是字节码">二、嘛是字节码？</h3>
<hr>
<p>​		Java具有跨平台特性，为了实现这个特性Java执行在一台虚拟机上，这个虚拟机就是JVM，Java通过JVM屏蔽了不同平台上之间的差异，从而做到一次编译，处处执行。</p>
<p>​		JVM位于Java编译器和OS平台之间，Java编译器只需要面向JVM，生成JVM能够理解的代码，这个代码就是字节码，JVM再把字节码翻译成真实机器能够理解的二进制机器码。</p>
<h3 id="三java语言的基本单元---类和包">三、Java语言的基本单元&mdash;类和包</h3>
<hr>
<h5 id="类">类</h5>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cat</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">//类名是Cat
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这就是一个类  
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span> <span style="color:#75715e">//class定义结束
</span></code></pre></div><p>要求：</p>
<ul>
<li>类名必须是英文字母开头，后接字母 数字和下划线的组合
<ul>
<li>习惯以大写字母开头</li>
</ul>
</li>
<li>好的类命名(见名知意)
<ul>
<li>getClass(获取class)</li>
<li>saveGithubPullRequestsToCSV(保存GitHub的pr到csv文件)</li>
<li>isEmpty(判断是不是空)</li>
</ul>
</li>
</ul>
<h5 id="为什么存在包这个东西">为什么存在<strong>包</strong>这个东西？</h5>
<hr>
<blockquote>
<p>在菜鸟网站上关于包(package)的第一句话是：</p>
<p>​	为了更好的组织类，Java提供了包机制，用来区别类名的命名空间。</p>
</blockquote>
<p>Java包这个机制是为了防止命名冲突，访问控制，提供搜索和定位类 接口 枚举 注释等。举个例子</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> com.keda725<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这两个类的区别在于哪里？好像是没有区别，那么可以直接在同一位置创建两个这样的java文件嘛？答案是否定的，那么这实际上是怎么创建两个内容上一样的文件的呢？</p>
<p><img src="/img/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/WX20200806-230702.png" alt=""></p>
<p>一个是在com.keda725下的Main，一个是在java下的Main，所以这两个并不是一个同一个类，而是两个不同的类。一个类处于哪个包中，取决于这个类存在的位置。</p>
<h5 id="包的作用">包的作用</h5>
<ul>
<li>把功能相似的类或者接口组织在同一个包中，方便类的查找和使用。</li>
<li>如同一个文件夹一样，包也采用树形目录的存储方式，同一个包中的类名字是不同的，不同包中的类是可以相同的，当同时调用两个不同包中相同类名的类时。应该加上包名加以区分，因此，包可以避免名字冲突。</li>
<li>限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Linux之硬链接和符号链接</title>
            <link>https://keda725.github.io/posts/2020/08/linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/</link>
            <pubDate>Wed, 05 Aug 2020 13:26:39 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/</guid>
            <description>从下面的现象中看有什么不同的地方？  mkdir ln //创建ln文件夹 cd ln	//进入到ln中 touch file1 //创建file1文件 ln file1 file2 //创建file1的一个硬链接文件file2 ln -s file1 file3 //创建file1的一个符号文件file3 ls -li //-i参数显示文件的inode索引节点号 echo &amp;#34;I am file1&amp;#34; &amp;gt;&amp;gt; file1 // 写入“”中的文字到file1 cat file1 //查看file1 cat file2 //查看file3 cat file3 //查看file3 rm -f file1 //强制删除file1 cat file2 //查看file2 cat file3 //查看file3 从上面的现象可以看出：当删除原始文件file1之后 硬链接file2不受影响 但是符号链接file3文件无效
Linux链接概念  硬链接(Hard Link)  硬链接通过索引节点来进行连接，在linux文件系统中，保存在磁盘分区中的文件不管是什么类型的都会被分配到一个编号 成为索引节点号(Inode Index)，在linux中 多个文件名指向同一个索引节点是存在的，一般这种连接就是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止误删的功能。只删除一个连接并不影响索引节点本身和其它链接。只有当最后一个链接被删除后，文件的数据块及目录才会被释放，也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。   符号链接(Symbolic Link)  也叫软链接，软链接文件有点像Windows中的快捷方式。实际上是一个特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一个文件的位置信息。    不知道你发现了什么没有？🤷‍♂️</description>
            <content type="html"><![CDATA[<h3 id="从下面的现象中看有什么不同的地方">从下面的现象中看有什么不同的地方？</h3>
<hr>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E7%8E%B0%E8%B1%A1.png" alt="现象"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">mkdir ln  									//创建ln文件夹
cd ln												//进入到ln中
touch file1  								//创建file1文件
ln file1 file2  						//创建file1的一个硬链接文件file2
ln -s file1 file3   				//创建file1的一个符号文件file3
ls -li             					//-i参数显示文件的inode索引节点号
echo <span style="color:#e6db74">&#34;I am file1&#34;</span> &gt;&gt; file1  // 写入<span style="color:#960050;background-color:#1e0010">“”</span>中的文字到file1
cat file1  									//查看file1
cat file2  									//查看file3
cat file3  									//查看file3
rm <span style="color:#f92672">-f</span> file1   							//强制删除file1
cat file2  									//查看file2   
cat file3  									//查看file3
</code></pre></div><p>从上面的现象可以看出：当删除原始文件file1之后 硬链接file2不受影响 但是符号链接file3文件无效</p>
<h4 id="linux链接概念">Linux链接概念</h4>
<ul>
<li>硬链接(Hard Link)
<ul>
<li>硬链接通过索引节点来进行连接，在linux文件系统中，保存在磁盘分区中的文件不管是什么类型的都会被分配到一个编号 成为索引节点号(Inode Index)，在linux中 多个文件名指向同一个索引节点是存在的，一般这种连接就是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止误删的功能。只删除一个连接并不影响索引节点本身和其它链接。只有当最后一个链接被删除后，文件的数据块及目录才会被释放，也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。</li>
</ul>
</li>
<li>符号链接(Symbolic Link)
<ul>
<li>也叫软链接，软链接文件有点像Windows中的快捷方式。实际上是一个特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一个文件的位置信息。</li>
</ul>
</li>
</ul>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E6%88%AA%E5%9B%BE.png" alt="截图"></p>
<p>不知道你发现了什么没有？🤷‍♂️</p>
<hr>
<p>如果你还有什么问题，没有通过Google找到答案，可以添加我的微信，我们一起Google找答案，如果你觉得我写的内容对你有帮助，你可以选择请我喝杯茶🍵</p>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E5%BE%AE%E4%BF%A1.png" alt="微信"></p>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.png" alt="微信支付"></p>
]]></content>
        </item>
        
        <item>
            <title>Filo和Io</title>
            <link>https://keda725.github.io/posts/2020/08/filo%E5%92%8Cio/</link>
            <pubDate>Wed, 05 Aug 2020 10:56:02 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/filo%E5%92%8Cio/</guid>
            <description>文件的本质就是一段字节流
一个字节有8个位
为什么两个两个来读字节？ bcd编码 8421
输入输出是站在应用程序的角度
InputStream
 read()  OutputStream
   从文件中读取
抽象类不能实例化的原因 因为这个类中包含着一些没有实现的抽象方法 假如允许 那实例化后 那些没有实现的方法 应该做什么呢
相对路径就好像是一个爸爸
相对路径只有在相对一个路径才有效
就好像你在家里叫爸爸才能到对应到一个人
但是你出们再乱叫爸爸 大家就会用异样的眼光看你
相对的路径 相对的就是jvm进程的当前工作目录
绝对路径就是 小明的爸爸
经典的io模型是基于流的
优点 容易理解 方便抽象 缺点 慢 必须一个一个的来
nio 块 没有顺序</description>
            <content type="html"><![CDATA[<p>文件的本质就是一段字节流</p>
<p>一个字节有8个位</p>
<p>为什么两个两个来读字节？  bcd编码 8421</p>
<p>输入输出是站在应用程序的角度</p>
<p>InputStream</p>
<ul>
<li>read()</li>
</ul>
<p>OutputStream</p>
<ul>
<li></li>
</ul>
<p>从文件中读取</p>
<p>抽象类不能实例化的原因 因为这个类中包含着一些没有实现的抽象方法 假如允许 那实例化后 那些没有实现的方法 应该做什么呢</p>
<p>相对路径就好像是一个爸爸</p>
<p>相对路径只有在相对一个路径才有效</p>
<p>就好像你在家里叫爸爸才能到对应到一个人</p>
<p>但是你出们再乱叫爸爸 大家就会用异样的眼光看你</p>
<p>相对的路径 相对的就是jvm进程的当前工作目录</p>
<p>绝对路径就是 小明的爸爸</p>
<p>经典的io模型是基于流的</p>
<p>优点 容易理解 方便抽象  缺点 慢  必须一个一个的来</p>
<p>nio 块 没有顺序</p>
]]></content>
        </item>
        
        <item>
            <title>Maven这个划时代的构建工具  Apache顶级项目</title>
            <link>https://keda725.github.io/posts/2020/08/maven%E8%BF%99%E4%B8%AA%E5%88%92%E6%97%B6%E4%BB%A3%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-apache%E9%A1%B6%E7%BA%A7%E9%A1%B9%E7%9B%AE/</link>
            <pubDate>Tue, 04 Aug 2020 23:52:59 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/maven%E8%BF%99%E4%B8%AA%E5%88%92%E6%97%B6%E4%BB%A3%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-apache%E9%A1%B6%E7%BA%A7%E9%A1%B9%E7%9B%AE/</guid>
            <description>1.Maven是啥：  Maven是Apache软件基金会唯一维护的一款自动化构建工具，专注于服务Java平台的项目构建和依赖管理。 Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。
2.Maven可以干啥：  添加第三方jar包 jar包之间的依赖关系： Maven 可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来 获取第三方jar包： Maven 提供了一个完全统一规范的 jar 包管理体系，只需要在项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载到本地仓库 将项目拆分成多个工程模块 构建项目（打包，编译等）
3.构建项目的几个主要环节：    清理（clean）：删除以前的编译结果，为重新编译做好准备
  编译（compile）：将Java 源程序编译为字节码文件
  测试（test）：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性
  报告：在每一次测试后以标准的格式记录和展示测试结果
  打包（package）：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web工程对应 war 包。
  安装（install）：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。
  部署（deploy）：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。
  4.maven常用命令   mvn -version/-v —— 显示版本信息 mvn clean —— 清空生成的文件 mvn compile —— 编译 mvn test —— 编译并测试 mvn package —— 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件 mvn site —— 生成项目相关信息的网站 mvn clean compile —— 表示先运行清理之后运行编译，会将代码编译到target文件夹中 mvn clean package —— 运行清理和打包 mvn clean install —— 运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用 mvn clean deploy —— 运行清理和发布  5.</description>
            <content type="html"><![CDATA[<h3 id="1maven是啥">1.Maven是啥：</h3>
<hr>
<p>Maven是Apache软件基金会唯一维护的一款自动化构建工具，专注于服务Java平台的项目构建和依赖管理。
Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。</p>
<h3 id="2maven可以干啥">2.Maven可以干啥：</h3>
<hr>
<p>添加第三方jar包
jar包之间的依赖关系： Maven 可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来
获取第三方jar包： Maven 提供了一个完全统一规范的 jar 包管理体系，只需要在项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载到本地仓库
将项目拆分成多个工程模块
构建项目（打包，编译等）</p>
<h3 id="3构建项目的几个主要环节">3.构建项目的几个主要环节：</h3>
<hr>
<ul>
<li>
<p>清理（clean）：删除以前的编译结果，为重新编译做好准备</p>
</li>
<li>
<p>编译（compile）：将Java 源程序编译为字节码文件</p>
</li>
<li>
<p>测试（test）：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性</p>
</li>
<li>
<p>报告：在每一次测试后以标准的格式记录和展示测试结果</p>
</li>
<li>
<p>打包（package）：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web工程对应 war 包。</p>
</li>
<li>
<p>安装（install）：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。</p>
</li>
<li>
<p>部署（deploy）：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</p>
</li>
</ul>
<h3 id="4maven常用命令">4.maven常用命令</h3>
<hr>
<ul>
<li>mvn -version/-v —— 显示版本信息</li>
<li>mvn clean —— 清空生成的文件</li>
<li>mvn compile  ——  编译</li>
<li>mvn test  ——  编译并测试</li>
<li>mvn package  ——  生成target目录，编译、测试代码，生成测试报告，生成jar/war文件</li>
<li>mvn site  ——  生成项目相关信息的网站</li>
<li>mvn clean compile  —— 表示先运行清理之后运行编译，会将代码编译到target文件夹中</li>
<li>mvn clean package  —— 运行清理和打包</li>
<li>mvn clean install ——  运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用</li>
<li>mvn clean deploy  —— 运行清理和发布</li>
</ul>
<h3 id="5maven核心概念">5.Maven核心概念</h3>
<hr>
<p>Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手， 看看 Maven 是如何实现自动化构建的</p>
<ul>
<li>POM</li>
<li>约定的目录结构</li>
<li>坐标</li>
<li>依赖管理</li>
<li>仓库管理</li>
<li>生命周期</li>
<li>插件和目标</li>
<li>继承</li>
<li>聚合</li>
</ul>
<p>Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是 Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2\repository。</p>
<h3 id="51-maven约定的工程目录">5.1. Maven约定的工程目录：</h3>
<hr>
<p>Java开发领域普遍认同的一个观点：约定&gt;配置&gt;编码（能用配置解决的问题就不编码，能基于约定的就不配置）</p>
<h3 id="52-pom">5.2. POM</h3>
<hr>
<p>Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。
Maven 工程的核心配置。</p>
<h3 id="53-坐标">5.3. 坐标</h3>
<p>Maven 的坐标 使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。</p>
<blockquote>
<p>groupid：公司或组织的域名倒序+当前项目名称</p>
</blockquote>
<blockquote>
<p>artifactId：当前项目的模块名称</p>
</blockquote>
<blockquote>
<p>version：当前模块的版本</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">  <span style="color:#f92672">&lt;groupId&gt;</span>net.lazyegg.maven<span style="color:#f92672">&lt;/groupId&gt;</span>
  <span style="color:#f92672">&lt;artifactId&gt;</span>Hello<span style="color:#f92672">&lt;/artifactId&gt;</span>
  <span style="color:#f92672">&lt;version&gt;</span>0.0.1-SNAPSHOT<span style="color:#f92672">&lt;/version&gt;</span>
</code></pre></div><p>如何通过坐标到仓库中查找 jar 包？</p>
<p>将 gav 三个向量连起来</p>
<p>net.lazyegg.maven+Hello+0.0.1-SNAPSHOT</p>
<p>以连起来的字符串作为目录结构到仓库中查找
net/lazyegg/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar</p>
<p>※ 注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install</p>
<h3 id="54-依赖">5.4. 依赖</h3>
<hr>
<p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决以下几个问题：
① 依赖的目的是什么
当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。那么如何在项目中以依赖的方式引入一个我们需要的 jar 包呢？ 答案非常简单，就是使用 dependency 标签指定被依赖 jar 包的坐标就可以了。</p>
]]></content>
        </item>
        
        <item>
            <title>CollectionMap由浅及深（一）</title>
            <link>https://keda725.github.io/posts/2020/08/collectionmap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%E4%B8%80/</link>
            <pubDate>Tue, 04 Aug 2020 23:52:22 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/collectionmap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%E4%B8%80/</guid>
            <description>Collection、Map由浅及深（一） Java集合类介绍： Java集合大致可以分为Set、List、Queue和Map四种体系
  Set代表无序、不可重复的集合；
  List代表有序、重复的集合；
  Map则代表具有映射关系的集合；
  Java 5 又增加了Queue体系集合，代表一种队列集合实现。
 Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型（此处以后会有链接）以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。
  集合和数组的区别：  数组长度在初始化时指定，只能保存定长的数据。 集合可以保存数量不确定的数据 同时可以保存具有映射关系的数据 （即关联数据 键值对 key-value） 数组元素即可以是基本数据的值 也可以是对象 集合中只能保存对象（即对象的引用变量）基本数据类型要转换成对应的包装类才能放在在集合中。   集合之间的继承关系 Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。
ArrayList,HashSet,LinkedList,TreeSet是经常用到的已实现的集合类。
Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。
图中，HashMap，TreeMap是我们经常会用到的集合类。
Collection 接口： 简介 Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。
 add 添加元素 addAll 添加所有元素到collection中 clear 清除collection中所有的元素 contains 如果collection中包含指定的元素 返回true equals 比较collection中包含的元素与指定元素是否相等 hashCode 返回collection的哈希值 isEmpty 如果collection中不包含元素 返回true iterator 返回在collection的元素上进行迭代的迭代器 remove 从此collection中移除指定元素的单个实例 removeAll 从此collection中所有的元素 retainAll 只保留此collection中那些包含制定collection的元素 size 返回collection中的元素数 toArray 返回包含此collection中所有元素的数组  可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。 其中重点介绍iterator()方法，该方法的返回值是Iterator。</description>
            <content type="html"><![CDATA[<h2 id="collectionmap由浅及深一">Collection、Map由浅及深（一）</h2>
<h3 id="java集合类介绍">Java集合类介绍：</h3>
<p>Java集合大致可以分为<strong>Set</strong>、<strong>List</strong>、<strong>Queue</strong>和<strong>Map</strong>四种体系</p>
<ul>
<li>
<p>Set代表无序、不可重复的集合；</p>
</li>
<li>
<p>List代表有序、重复的集合；</p>
</li>
<li>
<p>Map则代表具有映射关系的集合；</p>
</li>
<li>
<p>Java 5 又增加了Queue体系集合，代表一种队列集合实现。</p>
<hr>
<p>Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型（此处以后会有链接）以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。</p>
</li>
</ul>
<h3 id="集合和数组的区别">集合和数组的区别：</h3>
<ul>
<li>数组长度在初始化时指定，只能保存定长的数据。</li>
<li>集合可以保存数量不确定的数据 同时可以保存具有映射关系的数据 （即关联数据 键值对 key-value）</li>
<li>数组元素即可以是基本数据的值 也可以是对象</li>
<li>集合中只能保存对象（即对象的引用变量）基本数据类型要转换成对应的包装类才能放在在集合中。</li>
</ul>
<hr>
<h3 id="集合之间的继承关系">集合之间的继承关系</h3>
<p>Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。</p>
<p><img src="/img/CollectionMap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%EF%BC%88%E4%B8%80%EF%BC%89/collection%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="collection结构图"></p>
<p>ArrayList,HashSet,LinkedList,TreeSet是经常用到的已实现的集合类。</p>
<p>Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。</p>
<p><img src="/img/CollectionMap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%EF%BC%88%E4%B8%80%EF%BC%89/map%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="map结构图"></p>
<p>图中，HashMap，TreeMap是我们经常会用到的集合类。</p>
<h3 id="collection-接口">Collection 接口：</h3>
<h4 id="简介">简介</h4>
<p>Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。</p>
<ul>
<li>add  添加元素</li>
<li>addAll  添加所有元素到collection中</li>
<li>clear 清除collection中所有的元素</li>
<li>contains 如果collection中包含指定的元素 返回true</li>
<li>equals 比较collection中包含的元素与指定元素是否相等</li>
<li>hashCode 返回collection的哈希值</li>
<li>isEmpty  如果collection中不包含元素 返回true</li>
<li>iterator 返回在collection的元素上进行迭代的迭代器</li>
<li>remove  从此collection中移除指定元素的单个实例</li>
<li>removeAll  从此collection中所有的元素</li>
<li>retainAll  只保留此collection中那些包含制定collection的元素</li>
<li>size 返回collection中的元素数</li>
<li>toArray 返回包含此collection中所有元素的数组</li>
</ul>
<p>可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。
其中重点介绍iterator()方法，该方法的返回值是Iterator<!-- raw HTML omitted -->。</p>
<h4 id="使用iterator遍历集合元素">使用Iterator遍历集合元素</h4>
<p>Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。
Iterator接口中主要定义了2个方法：</p>
<p>boolean hasNext()			如果仍有元素可以迭代 则返回true</p>
<p>E              next()                   返回迭代的下一个元素</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IteratorDemo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">//创建集合 添加元素
</span><span style="color:#75715e"></span>        Collection<span style="color:#f92672">&lt;</span>Day<span style="color:#f92672">&gt;</span> days <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Day<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 10<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            Day day <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Day<span style="color:#f92672">(</span>i<span style="color:#f92672">,</span>i<span style="color:#f92672">*</span>60<span style="color:#f92672">,</span>i<span style="color:#f92672">*</span>3600<span style="color:#f92672">);</span>
            days<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>day<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
      <span style="color:#75715e">//获取days集合的迭代器
</span><span style="color:#75715e"></span>        Iterator<span style="color:#f92672">&lt;</span>Day<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> days<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
      <span style="color:#75715e">//判断是否有下一个元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            Day next <span style="color:#f92672">=</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
          <span style="color:#75715e">//逐个遍历 获取元素后进行后续操作
</span><span style="color:#75715e"></span>         <span style="color:#f92672">...</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>当使用Iterator对集合元素进行迭代时，Iterator并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量，所以修改迭代变量的值对集合元素本身没有任何影响。</strong></p>
<p>就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IteratorExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;java语言&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;C语言&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;C++语言&#34;</span><span style="color:#f92672">);</span>
        Iterator<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">()){</span>
          <span style="color:#75715e">//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址
</span><span style="color:#75715e"></span>            String next <span style="color:#f92672">=</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
            next <span style="color:#f92672">=</span><span style="color:#e6db74">&#34;修改后的&#34;</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>next<span style="color:#f92672">);</span>
            
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>list<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Hugo从无到有以及图片处理问题</title>
            <link>https://keda725.github.io/posts/2020/08/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/</link>
            <pubDate>Tue, 04 Aug 2020 22:55:58 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/2020/08/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/</guid>
            <description>为什么选择hugo?  ​	因为也是刚刚开始搭建自己的博客，看了CodeSheep程序羊老哥以前介绍的hugo，是基于go语言写的，特点就是快，也符合我们当代年轻人的特点(😁)，另外就是搭建起来也很方便 简单几个命令，就可以看到成果，不至于半途而废。(另外google了一下为什么选择hugo？看看别人是怎么说的 机灵鬼.gif)
​	第一点得提的就是Hugo 打出的标语 &amp;ndash; “The world’s fastest framework for building websites”。Hugo 依靠Go语言进行开发，号称世界上最快的构建网站工具，到底有多快？根据相关博主提供的数据，他200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。就我个人的体验来说，Hugo确实大大加快了网页生成的速度，平常增加一篇博文然后再生成渲染需要4秒左右，而Hugo基本上是1秒内完成。正是依赖于Hugo 快速生成的特点，调试方便成了Hugo的第二大特点。基本上我在源文件处修改的内容可以实时地显示在网页上，而不用再次敲代码生成再预览，这对于博主来说简直就是一个福音。
放个链接 看看能不能说服你？
hugo从0到1  ​	我建议和我一样的新手 不要直接google搜索 hugo搭建博客 因为有的时候 在别人那行得通 但是到自己这里不行 就会怀疑自己的能力，是不是自己太辣鸡，其实是有的时候写博客，只是为了自己记录一下，可能把有些步骤给省略了，但是官网不会啊，官网就是想让你都能完成，都来使用，所以步骤都会写的很清楚，所以我先把**官网**放在链接里，大家通过查阅文档，有问题了再来看我的博客，这样学习起来，自己的印象也会比较深。
​	odk，废话不多说，我开始啦！（我的环境是macOS）
No1 下载Hugo mac推荐是用homebrew 我后面会写homebrew的教程 这里先欠着哈  brew install hugo //使用brew下载hugo hugo version	//查看hugo版本 确定是否下载成功 看到这个就代表你成功下载了Hugo!!! 🎉🎉🎉
No2 Hugo 创建一个博客 hugo new site xxx //xxx 是你文件的名字 hugo new site keda725.github.io 你就会发现Hugo在当前路径下创建了一个keda725.github.io的文件夹，可以看到Hugo为我们创建了一些文件，themes，date，static等。
|- archetypes ：存放default.md，头文件格式 |- content ：content目录存放博客文章（markdown文件） |- data ：存放自定义模版，导入的toml文件（或json，yaml） |- layouts ：layouts目录存放的是网站的模板文件 |- static ：static目录存放图片，css等静态资源 |- themes ：存放网站主题文件 |- config.</description>
            <content type="html"><![CDATA[<h4 id="为什么选择hugo">为什么选择hugo?</h4>
<hr>
<p>​		因为也是刚刚开始搭建自己的博客，看了<a href="https://space.bilibili.com/384068749/">CodeSheep</a>程序羊老哥以前介绍的hugo，是基于go语言写的，特点就是快，也符合我们当代年轻人的特点(😁)，另外就是搭建起来也很方便 简单几个命令，就可以看到成果，不至于半途而废。(另外google了一下为什么选择hugo？看看别人是怎么说的 机灵鬼.gif)</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/hugo%E5%AE%98%E7%BD%91%E6%88%AA%E5%9B%BE.png" alt="hugo官网截图"></p>
<p>​		第一点得提的就是Hugo 打出的标语 &ndash; “The world’s fastest framework for building websites”。Hugo 依靠Go语言进行开发，号称世界上最快的构建网站工具，到底有多快？根据相关博主提供的数据，他200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。就我个人的体验来说，Hugo确实大大加快了网页生成的速度，平常增加一篇博文然后再生成渲染需要4秒左右，而Hugo基本上是1秒内完成。正是依赖于Hugo 快速生成的特点，调试方便成了Hugo的第二大特点。基本上我在源文件处修改的内容可以实时地显示在网页上，而不用再次敲代码生成再预览，这对于博主来说简直就是一个福音。</p>
<p><strong><a href="https://sspai.com/post/59904">放个链接 看看能不能说服你？</a></strong></p>
<h4 id="hugo从0到1">hugo从0到1</h4>
<hr>
<p>​		我建议和我一样的新手 不要直接google搜索 hugo搭建博客 因为有的时候 在别人那行得通 但是到自己这里不行 就会怀疑自己的能力，是不是自己太辣鸡，其实是有的时候写博客，只是为了自己记录一下，可能把有些步骤给省略了，但是官网不会啊，官网就是想让你都能完成，都来使用，所以步骤都会写的很清楚，所以我先把**<a href="https://gohugo.io/getting-started/quick-start/">官网</a>**放在链接里，大家通过查阅文档，有问题了再来看我的博客，这样学习起来，自己的印象也会比较深。</p>
<p>​		odk，废话不多说，我开始啦！（我的环境是macOS）</p>
<h5 id="no1-下载hugo-mac推荐是用homebrew-我后面会写homebrew的教程-这里先欠着哈">No1 下载Hugo mac推荐是用homebrew 我后面会写homebrew的教程 这里先欠着哈</h5>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">brew install hugo   //使用brew下载hugo
hugo version				//查看hugo版本 确定是否下载成功
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/version.png" alt=""></p>
<p>看到这个就代表你成功下载了Hugo!!! 🎉🎉🎉</p>
<h5 id="no2-hugo-创建一个博客">No2 Hugo 创建一个博客</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo new site xxx  //xxx 是你文件的名字

hugo new site keda725.github.io
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/newsite.png" alt=""></p>
<p>你就会发现Hugo在当前路径下创建了一个keda725.github.io的文件夹，可以看到Hugo为我们创建了一些文件，themes，date，static等。</p>
<p>|- archetypes ：存放default.md，头文件格式
|- content ：content目录存放博客文章（markdown文件）
|- data ：存放自定义模版，导入的toml文件（或json，yaml）
|- layouts ：layouts目录存放的是网站的模板文件
|- static ：static目录存放图片，css等静态资源
|- themes ：存放网站主题文件
|- config.toml ：config.toml是网站的配置文件</p>
<h5 id="no3-选择一个主题">No3 选择一个主题</h5>
<hr>
<p>强烈推荐<a href="https://themes.gohugo.io/hugo-theme-hello-friend-ng/">hello-friend-ng</a>这个主题，自认为是很赞的一个主题，当然看大家自己的选择喽，我下面的介绍以及图片问题的处理，都是根据这个主题来介绍的。</p>
<p>注意，从现在开始到动作都是在keda725.github.io这个路径下的操作了，不要在～下面搞，还要复制粘贴一道，浪费时间！</p>
<p>git的安装和使用 这里就先不说了，先放一个官方的<a href="https://git-scm.com/">文档链接</a>！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">git clone https<span style="color:#960050;background-color:#1e0010">:</span>//github.com/rhazdon/hugo-theme-hello-friend-ng.git themes/hello-friend-ng 
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/theme.png" alt=""></p>
<p>这就说明主题下载成功啦 我们先启动一下hugo 看看效果，让自己也有点成就感！</p>
<h5 id="no4-启动hugo">No4 启动Hugo</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo server -t hello-friend-ng -D 
</code></pre></div><ul>
<li>-t是&ndash;theme的缩写 声明主题是hello-friend-ng</li>
<li>-D是&ndash;buildDrafts的缩写  连草稿一同展示出来</li>
</ul>
<p>也可以在执行这一步之前把theme写入到config.toml中</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">echo <span style="color:#e6db74">&#39;theme = &#34;hello-friend-ng &#34;&#39;</span> &gt;&gt; config.toml
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/server.png" alt="server"></p>
<p>然后在网址上输入http://localhost:1313/就可以看到在本地启动的hugo博客啦！</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/hello.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/hello2.png" alt=""></p>
<p>这个主题有白天和黑夜两种模式可以选择，默认是黑色的。</p>
<p>做到这里我们只是把选择了一个主题和成功启动了hugo，那么接下来我们就开始一下我们的博客编写和配置啦！</p>
<h5 id="no5-写一篇博客">No5 写一篇博客</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo new posts/第一篇博客.md
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2.png" alt=""></p>
<p>然后我们按住键盘的command win上应该是control 鼠标放在第一篇博客上 打开这个md文件</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%8D%9A%E5%AE%A2.png" alt="博客"></p>
<p>随便写两句 慢慢来！</p>
<h5 id="no6-再次启动hugo">No6 再次启动hugo</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo server -t hello-friend-ng -D
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%86%8D%E6%AC%A1%E5%90%AF%E5%8A%A8.png" alt=""></p>
<p>发现并没有文章发不上来，不要慌，这是因为我们针对这个主题还没有配置主菜单。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">cd themes/hello-friend-ng/exampleSite/
</code></pre></div><p>打开config.toml 可以用vscode 或者vim  添加如下内容后保存，然后把这个config.toml拷贝一份放在keda725.github.io文件夹下替换原有的config.toml</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">[[<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">main</span>]]
   <span style="color:#a6e22e">identifier</span> = <span style="color:#e6db74">&#34;blog&#34;</span>
   <span style="color:#a6e22e">name</span>       = <span style="color:#e6db74">&#34;Blogs&#34;</span>
   <span style="color:#a6e22e">url</span>        = <span style="color:#e6db74">&#34;/posts&#34;</span>

 [[<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">main</span>]]
   <span style="color:#a6e22e">identifier</span> = <span style="color:#e6db74">&#34;categories&#34;</span>
   <span style="color:#a6e22e">name</span>       = <span style="color:#e6db74">&#34;Categories&#34;</span>
   <span style="color:#a6e22e">url</span>        = <span style="color:#e6db74">&#34;/categories/&#34;</span>

 [[<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">main</span>]]
   <span style="color:#a6e22e">identifier</span> = <span style="color:#e6db74">&#34;tags&#34;</span>
   <span style="color:#a6e22e">name</span>       = <span style="color:#e6db74">&#34;Tags&#34;</span>
   <span style="color:#a6e22e">url</span>        = <span style="color:#e6db74">&#34;/tags/&#34;</span>

</code></pre></div><p>然后重新启动hugo server</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E9%85%8D%E7%BD%AE%E5%90%8E.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E9%85%8D%E7%BD%AE%E5%90%8E2.png" alt=""></p>
<h3 id="如果想要插入图片在typora中是这样的">如果想要插入图片，在Typora中是这样的：</h3>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%871.png" alt="插入图片2"></p>
<p>我不知道我讲清楚没有 如有问题 可以加我微信TSKB1996</p>
<h4 id="将博客部署在github上">将博客部署在GitHub上</h4>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%92%8Cgithub%E5%85%B3%E8%81%94.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E7%94%9F%E6%88%90public%E6%96%87%E4%BB%B6.png" alt="生成public文件"></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/gitinit.png" alt="gitinit"></p>
<p>初始化仓库的时候是在public上 我们上传的只是public这个文件夹</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">git init
git remote add origin https<span style="color:#960050;background-color:#1e0010">:</span>//github.com/xxx/xxx.github.io.git //你的github名
git commit -m <span style="color:#e6db74">&#34;xxx&#34;</span>  //你提交的信息
git push -u origin master
</code></pre></div><hr>
<p>这就是所有的内容啦！！🎉🎉🎉</p>
<p>剩余的一些个性化设置 就由你自己来完成啦！</p>
<p>如果你还有问题 欢迎添加我的微信 或者你觉得我写的不错想请我喝杯茶🍵</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E4%BA%8C%E7%BB%B4%E7%A0%811.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E4%BA%8C%E7%BB%B4%E7%A0%812.png" alt=""></p>
]]></content>
        </item>
        
    </channel>
</rss>
