<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Be determined to have a great day and you will!</title>
        <link>https://keda725.github.io/posts/</link>
        <description>Recent content in Posts on Be determined to have a great day and you will!</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-Hans</language>
        <lastBuildDate>Wed, 05 Aug 2020 13:26:39 +0800</lastBuildDate>
        <atom:link href="https://keda725.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Linux之硬链接和符号链接</title>
            <link>https://keda725.github.io/posts/linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/</link>
            <pubDate>Wed, 05 Aug 2020 13:26:39 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/</guid>
            <description>从下面的现象中看有什么不同的地方？  mkdir ln //创建ln文件夹 cd ln	//进入到ln中 touch file1 //创建file1文件 ln file1 file2 //创建file1的一个硬链接文件file2 ln -s file1 file3 //创建file1的一个符号文件file3 ls -li //-i参数显示文件的inode索引节点号 echo &amp;#34;I am file1&amp;#34; &amp;gt;&amp;gt; file1 // 写入“”中的文字到file1 cat file1 //查看file1 cat file2 //查看file3 cat file3 //查看file3 rm -f file1 //强制删除file1 cat file2 //查看file2 cat file3 //查看file3 从上面的现象可以看出：当删除原始文件file1之后 硬链接file2不受影响 但是符号链接file3文件无效
Linux链接概念  硬链接(Hard Link)  硬链接通过索引节点来进行连接，在linux文件系统中，保存在磁盘分区中的文件不管是什么类型的都会被分配到一个编号 成为索引节点号(Inode Index)，在linux中 多个文件名指向同一个索引节点是存在的，一般这种连接就是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止误删的功能。只删除一个连接并不影响索引节点本身和其它链接。只有当最后一个链接被删除后，文件的数据块及目录才会被释放，也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。   符号链接(Symbolic Link)  也叫软链接，软链接文件有点像Windows中的快捷方式。实际上是一个特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一个文件的位置信息。    不知道你发现了什么没有？🤷‍♂️</description>
            <content type="html"><![CDATA[<h3 id="从下面的现象中看有什么不同的地方">从下面的现象中看有什么不同的地方？</h3>
<hr>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E7%8E%B0%E8%B1%A1.png" alt="现象"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">mkdir ln  									//创建ln文件夹
cd ln												//进入到ln中
touch file1  								//创建file1文件
ln file1 file2  						//创建file1的一个硬链接文件file2
ln -s file1 file3   				//创建file1的一个符号文件file3
ls -li             					//-i参数显示文件的inode索引节点号
echo <span style="color:#e6db74">&#34;I am file1&#34;</span> &gt;&gt; file1  // 写入<span style="color:#960050;background-color:#1e0010">“”</span>中的文字到file1
cat file1  									//查看file1
cat file2  									//查看file3
cat file3  									//查看file3
rm <span style="color:#f92672">-f</span> file1   							//强制删除file1
cat file2  									//查看file2   
cat file3  									//查看file3
</code></pre></div><p>从上面的现象可以看出：当删除原始文件file1之后 硬链接file2不受影响 但是符号链接file3文件无效</p>
<h4 id="linux链接概念">Linux链接概念</h4>
<ul>
<li>硬链接(Hard Link)
<ul>
<li>硬链接通过索引节点来进行连接，在linux文件系统中，保存在磁盘分区中的文件不管是什么类型的都会被分配到一个编号 成为索引节点号(Inode Index)，在linux中 多个文件名指向同一个索引节点是存在的，一般这种连接就是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止误删的功能。只删除一个连接并不影响索引节点本身和其它链接。只有当最后一个链接被删除后，文件的数据块及目录才会被释放，也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。</li>
</ul>
</li>
<li>符号链接(Symbolic Link)
<ul>
<li>也叫软链接，软链接文件有点像Windows中的快捷方式。实际上是一个特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一个文件的位置信息。</li>
</ul>
</li>
</ul>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E6%88%AA%E5%9B%BE.png" alt="截图"></p>
<p>不知道你发现了什么没有？🤷‍♂️</p>
<hr>
<p>如果你还有什么问题，没有通过Google找到答案，可以添加我的微信，我们一起Google找答案，如果你觉得我写的内容对你有帮助，你可以选择请我喝杯茶🍵</p>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E5%BE%AE%E4%BF%A1.png" alt="微信"></p>
<p><img src="/img/Linux%E4%B9%8B%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.png" alt="微信支付"></p>
]]></content>
        </item>
        
        <item>
            <title>Filo和Io</title>
            <link>https://keda725.github.io/posts/filo%E5%92%8Cio/</link>
            <pubDate>Wed, 05 Aug 2020 10:56:02 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/filo%E5%92%8Cio/</guid>
            <description>文件的本质就是一段字节流
一个字节有8个位
为什么两个两个来读字节？ bcd编码 8421
输入输出是站在应用程序的角度
InputStream
 read()  OutputStream
   从文件中读取
抽象类不能实例化的原因 因为这个类中包含着一些没有实现的抽象方法 假如允许 那实例化后 那些没有实现的方法 应该做什么呢
相对路径就好像是一个爸爸
相对路径只有在相对一个路径才有效
就好像你在家里叫爸爸才能到对应到一个人
但是你出们再乱叫爸爸 大家就会用异样的眼光看你
相对的路径 相对的就是jvm进程的当前工作目录
绝对路径就是 小明的爸爸</description>
            <content type="html"><![CDATA[<p>文件的本质就是一段字节流</p>
<p>一个字节有8个位</p>
<p>为什么两个两个来读字节？  bcd编码 8421</p>
<p>输入输出是站在应用程序的角度</p>
<p>InputStream</p>
<ul>
<li>read()</li>
</ul>
<p>OutputStream</p>
<ul>
<li></li>
</ul>
<p>从文件中读取</p>
<p>抽象类不能实例化的原因 因为这个类中包含着一些没有实现的抽象方法 假如允许 那实例化后 那些没有实现的方法 应该做什么呢</p>
<p>相对路径就好像是一个爸爸</p>
<p>相对路径只有在相对一个路径才有效</p>
<p>就好像你在家里叫爸爸才能到对应到一个人</p>
<p>但是你出们再乱叫爸爸 大家就会用异样的眼光看你</p>
<p>相对的路径 相对的就是jvm进程的当前工作目录</p>
<p>绝对路径就是 小明的爸爸</p>
]]></content>
        </item>
        
        <item>
            <title>Maven这个划时代的构建工具  Apache顶级项目</title>
            <link>https://keda725.github.io/posts/maven%E8%BF%99%E4%B8%AA%E5%88%92%E6%97%B6%E4%BB%A3%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-apache%E9%A1%B6%E7%BA%A7%E9%A1%B9%E7%9B%AE/</link>
            <pubDate>Tue, 04 Aug 2020 23:52:59 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/maven%E8%BF%99%E4%B8%AA%E5%88%92%E6%97%B6%E4%BB%A3%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-apache%E9%A1%B6%E7%BA%A7%E9%A1%B9%E7%9B%AE/</guid>
            <description>1.Maven是啥：  Maven是Apache软件基金会唯一维护的一款自动化构建工具，专注于服务Java平台的项目构建和依赖管理。 Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。
2.Maven可以干啥：  添加第三方jar包 jar包之间的依赖关系： Maven 可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来 获取第三方jar包： Maven 提供了一个完全统一规范的 jar 包管理体系，只需要在项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载到本地仓库 将项目拆分成多个工程模块 构建项目（打包，编译等）
3.构建项目的几个主要环节：    清理（clean）：删除以前的编译结果，为重新编译做好准备
  编译（compile）：将Java 源程序编译为字节码文件
  测试（test）：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性
  报告：在每一次测试后以标准的格式记录和展示测试结果
  打包（package）：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web工程对应 war 包。
  安装（install）：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。
  部署（deploy）：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。
  4.maven常用命令   mvn -version/-v —— 显示版本信息 mvn clean —— 清空生成的文件 mvn compile —— 编译 mvn test —— 编译并测试 mvn package —— 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件 mvn site —— 生成项目相关信息的网站 mvn clean compile —— 表示先运行清理之后运行编译，会将代码编译到target文件夹中 mvn clean package —— 运行清理和打包 mvn clean install —— 运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用 mvn clean deploy —— 运行清理和发布  5.</description>
            <content type="html"><![CDATA[<h3 id="1maven是啥">1.Maven是啥：</h3>
<hr>
<p>Maven是Apache软件基金会唯一维护的一款自动化构建工具，专注于服务Java平台的项目构建和依赖管理。
Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。</p>
<h3 id="2maven可以干啥">2.Maven可以干啥：</h3>
<hr>
<p>添加第三方jar包
jar包之间的依赖关系： Maven 可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来
获取第三方jar包： Maven 提供了一个完全统一规范的 jar 包管理体系，只需要在项目中以坐标的方式依赖一个 jar 包，Maven 就会自动从中央仓库进行下载到本地仓库
将项目拆分成多个工程模块
构建项目（打包，编译等）</p>
<h3 id="3构建项目的几个主要环节">3.构建项目的几个主要环节：</h3>
<hr>
<ul>
<li>
<p>清理（clean）：删除以前的编译结果，为重新编译做好准备</p>
</li>
<li>
<p>编译（compile）：将Java 源程序编译为字节码文件</p>
</li>
<li>
<p>测试（test）：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性</p>
</li>
<li>
<p>报告：在每一次测试后以标准的格式记录和展示测试结果</p>
</li>
<li>
<p>打包（package）：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web工程对应 war 包。</p>
</li>
<li>
<p>安装（install）：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。</p>
</li>
<li>
<p>部署（deploy）：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。</p>
</li>
</ul>
<h3 id="4maven常用命令">4.maven常用命令</h3>
<hr>
<ul>
<li>mvn -version/-v —— 显示版本信息</li>
<li>mvn clean —— 清空生成的文件</li>
<li>mvn compile  ——  编译</li>
<li>mvn test  ——  编译并测试</li>
<li>mvn package  ——  生成target目录，编译、测试代码，生成测试报告，生成jar/war文件</li>
<li>mvn site  ——  生成项目相关信息的网站</li>
<li>mvn clean compile  —— 表示先运行清理之后运行编译，会将代码编译到target文件夹中</li>
<li>mvn clean package  —— 运行清理和打包</li>
<li>mvn clean install ——  运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用</li>
<li>mvn clean deploy  —— 运行清理和发布</li>
</ul>
<h3 id="5maven核心概念">5.Maven核心概念</h3>
<hr>
<p>Maven 能够实现自动化构建是和它的内部原理分不开的，这里我们从 Maven 的九个核心概念入手， 看看 Maven 是如何实现自动化构建的</p>
<ul>
<li>POM</li>
<li>约定的目录结构</li>
<li>坐标</li>
<li>依赖管理</li>
<li>仓库管理</li>
<li>生命周期</li>
<li>插件和目标</li>
<li>继承</li>
<li>聚合</li>
</ul>
<p>Maven 的核心程序中仅仅定义了抽象的生命周期，而具体的操作则是由 Maven 的插件来完成的。可是 Maven 的插件并不包含在 Maven 的核心程序中，在首次使用时需要联网下载。 下载得到的插件会被保存到本地仓库中。本地仓库默认的位置是：~.m2\repository。</p>
<h3 id="51-maven约定的工程目录">5.1. Maven约定的工程目录：</h3>
<hr>
<p>Java开发领域普遍认同的一个观点：约定&gt;配置&gt;编码（能用配置解决的问题就不编码，能基于约定的就不配置）</p>
<h3 id="52-pom">5.2. POM</h3>
<hr>
<p>Project Object Model：项目对象模型。将 Java 工程的相关信息封装为对象作为便于操作和管理的模型。
Maven 工程的核心配置。</p>
<h3 id="53-坐标">5.3. 坐标</h3>
<p>Maven 的坐标 使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。</p>
<blockquote>
<p>groupid：公司或组织的域名倒序+当前项目名称</p>
</blockquote>
<blockquote>
<p>artifactId：当前项目的模块名称</p>
</blockquote>
<blockquote>
<p>version：当前模块的版本</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">  <span style="color:#f92672">&lt;groupId&gt;</span>net.lazyegg.maven<span style="color:#f92672">&lt;/groupId&gt;</span>
  <span style="color:#f92672">&lt;artifactId&gt;</span>Hello<span style="color:#f92672">&lt;/artifactId&gt;</span>
  <span style="color:#f92672">&lt;version&gt;</span>0.0.1-SNAPSHOT<span style="color:#f92672">&lt;/version&gt;</span>
</code></pre></div><p>如何通过坐标到仓库中查找 jar 包？</p>
<p>将 gav 三个向量连起来</p>
<p>net.lazyegg.maven+Hello+0.0.1-SNAPSHOT</p>
<p>以连起来的字符串作为目录结构到仓库中查找
net/lazyegg/maven/Hello/0.0.1-SNAPSHOT/Hello-0.0.1-SNAPSHOT.jar</p>
<p>※ 注意：我们自己的 Maven 工程必须执行安装操作才会进入仓库。安装的命令是：mvn install</p>
<h3 id="54-依赖">5.4. 依赖</h3>
<hr>
<p>Maven 中最关键的部分，我们使用 Maven 最主要的就是使用它的依赖管理功能。要理解和掌握 Maven 的依赖管理，我们只需要解决以下几个问题：
① 依赖的目的是什么
当 A jar 包用到了 B jar 包中的某些类时，A 就对 B 产生了依赖，这是概念上的描述。那么如何在项目中以依赖的方式引入一个我们需要的 jar 包呢？ 答案非常简单，就是使用 dependency 标签指定被依赖 jar 包的坐标就可以了。</p>
]]></content>
        </item>
        
        <item>
            <title>CollectionMap由浅及深（一）</title>
            <link>https://keda725.github.io/posts/collectionmap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%E4%B8%80/</link>
            <pubDate>Tue, 04 Aug 2020 23:52:22 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/collectionmap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%E4%B8%80/</guid>
            <description>Collection、Map由浅及深（一） Java集合类介绍： Java集合大致可以分为Set、List、Queue和Map四种体系
  Set代表无序、不可重复的集合；
  List代表有序、重复的集合；
  Map则代表具有映射关系的集合；
  Java 5 又增加了Queue体系集合，代表一种队列集合实现。
 Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型（此处以后会有链接）以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。
  集合和数组的区别：  数组长度在初始化时指定，只能保存定长的数据。 集合可以保存数量不确定的数据 同时可以保存具有映射关系的数据 （即关联数据 键值对 key-value） 数组元素即可以是基本数据的值 也可以是对象 集合中只能保存对象（即对象的引用变量）基本数据类型要转换成对应的包装类才能放在在集合中。   集合之间的继承关系 Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。
ArrayList,HashSet,LinkedList,TreeSet是经常用到的已实现的集合类。
Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。
图中，HashMap，TreeMap是我们经常会用到的集合类。
Collection 接口： 简介 Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。
 add 添加元素 addAll 添加所有元素到collection中 clear 清除collection中所有的元素 contains 如果collection中包含指定的元素 返回true equals 比较collection中包含的元素与指定元素是否相等 hashCode 返回collection的哈希值 isEmpty 如果collection中不包含元素 返回true iterator 返回在collection的元素上进行迭代的迭代器 remove 从此collection中移除指定元素的单个实例 removeAll 从此collection中所有的元素 retainAll 只保留此collection中那些包含制定collection的元素 size 返回collection中的元素数 toArray 返回包含此collection中所有元素的数组  可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。 其中重点介绍iterator()方法，该方法的返回值是Iterator。</description>
            <content type="html"><![CDATA[<h2 id="collectionmap由浅及深一">Collection、Map由浅及深（一）</h2>
<h3 id="java集合类介绍">Java集合类介绍：</h3>
<p>Java集合大致可以分为<strong>Set</strong>、<strong>List</strong>、<strong>Queue</strong>和<strong>Map</strong>四种体系</p>
<ul>
<li>
<p>Set代表无序、不可重复的集合；</p>
</li>
<li>
<p>List代表有序、重复的集合；</p>
</li>
<li>
<p>Map则代表具有映射关系的集合；</p>
</li>
<li>
<p>Java 5 又增加了Queue体系集合，代表一种队列集合实现。</p>
<hr>
<p>Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型（此处以后会有链接）以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。</p>
</li>
</ul>
<h3 id="集合和数组的区别">集合和数组的区别：</h3>
<ul>
<li>数组长度在初始化时指定，只能保存定长的数据。</li>
<li>集合可以保存数量不确定的数据 同时可以保存具有映射关系的数据 （即关联数据 键值对 key-value）</li>
<li>数组元素即可以是基本数据的值 也可以是对象</li>
<li>集合中只能保存对象（即对象的引用变量）基本数据类型要转换成对应的包装类才能放在在集合中。</li>
</ul>
<hr>
<h3 id="集合之间的继承关系">集合之间的继承关系</h3>
<p>Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。</p>
<p><img src="/img/CollectionMap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%EF%BC%88%E4%B8%80%EF%BC%89/collection%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="collection结构图"></p>
<p>ArrayList,HashSet,LinkedList,TreeSet是经常用到的已实现的集合类。</p>
<p>Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。</p>
<p><img src="/img/CollectionMap%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%EF%BC%88%E4%B8%80%EF%BC%89/map%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="map结构图"></p>
<p>图中，HashMap，TreeMap是我们经常会用到的集合类。</p>
<h3 id="collection-接口">Collection 接口：</h3>
<h4 id="简介">简介</h4>
<p>Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。</p>
<ul>
<li>add  添加元素</li>
<li>addAll  添加所有元素到collection中</li>
<li>clear 清除collection中所有的元素</li>
<li>contains 如果collection中包含指定的元素 返回true</li>
<li>equals 比较collection中包含的元素与指定元素是否相等</li>
<li>hashCode 返回collection的哈希值</li>
<li>isEmpty  如果collection中不包含元素 返回true</li>
<li>iterator 返回在collection的元素上进行迭代的迭代器</li>
<li>remove  从此collection中移除指定元素的单个实例</li>
<li>removeAll  从此collection中所有的元素</li>
<li>retainAll  只保留此collection中那些包含制定collection的元素</li>
<li>size 返回collection中的元素数</li>
<li>toArray 返回包含此collection中所有元素的数组</li>
</ul>
<p>可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。
其中重点介绍iterator()方法，该方法的返回值是Iterator<!-- raw HTML omitted -->。</p>
<h4 id="使用iterator遍历集合元素">使用Iterator遍历集合元素</h4>
<p>Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。
Iterator接口中主要定义了2个方法：</p>
<p>boolean hasNext()			如果仍有元素可以迭代 则返回true</p>
<p>E              next()                   返回迭代的下一个元素</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IteratorDemo</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">//创建集合 添加元素
</span><span style="color:#75715e"></span>        Collection<span style="color:#f92672">&lt;</span>Day<span style="color:#f92672">&gt;</span> days <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Day<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 10<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            Day day <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Day<span style="color:#f92672">(</span>i<span style="color:#f92672">,</span>i<span style="color:#f92672">*</span>60<span style="color:#f92672">,</span>i<span style="color:#f92672">*</span>3600<span style="color:#f92672">);</span>
            days<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>day<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
      <span style="color:#75715e">//获取days集合的迭代器
</span><span style="color:#75715e"></span>        Iterator<span style="color:#f92672">&lt;</span>Day<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> days<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
      <span style="color:#75715e">//判断是否有下一个元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            Day next <span style="color:#f92672">=</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
          <span style="color:#75715e">//逐个遍历 获取元素后进行后续操作
</span><span style="color:#75715e"></span>         <span style="color:#f92672">...</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>当使用Iterator对集合元素进行迭代时，Iterator并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量，所以修改迭代变量的值对集合元素本身没有任何影响。</strong></p>
<p>就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IteratorExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;java语言&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;C语言&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;C++语言&#34;</span><span style="color:#f92672">);</span>
        Iterator<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">()){</span>
          <span style="color:#75715e">//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址
</span><span style="color:#75715e"></span>            String next <span style="color:#f92672">=</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
            next <span style="color:#f92672">=</span><span style="color:#e6db74">&#34;修改后的&#34;</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>next<span style="color:#f92672">);</span>
            
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>list<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Hugo从无到有以及图片处理问题</title>
            <link>https://keda725.github.io/posts/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98-2/</link>
            <pubDate>Tue, 04 Aug 2020 22:55:58 +0800</pubDate>
            
            <guid>https://keda725.github.io/posts/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98-2/</guid>
            <description>为什么选择hugo?  ​	因为也是刚刚开始搭建自己的博客，看了CodeSheep程序羊老哥以前介绍的hugo，是基于go语言写的，特点就是快，也符合我们当代年轻人的特点(😁)，另外就是搭建起来也很方便 简单几个命令，就可以看到成果，不至于半途而废。(另外google了一下为什么选择hugo？看看别人是怎么说的 机灵鬼.gif)
​	第一点得提的就是Hugo 打出的标语 &amp;ndash; “The world’s fastest framework for building websites”。Hugo 依靠Go语言进行开发，号称世界上最快的构建网站工具，到底有多快？根据相关博主提供的数据，他200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。就我个人的体验来说，Hugo确实大大加快了网页生成的速度，平常增加一篇博文然后再生成渲染需要4秒左右，而Hugo基本上是1秒内完成。正是依赖于Hugo 快速生成的特点，调试方便成了Hugo的第二大特点。基本上我在源文件处修改的内容可以实时地显示在网页上，而不用再次敲代码生成再预览，这对于博主来说简直就是一个福音。
放个链接 看看能不能说服你？
hugo从0到1  ​	我建议和我一样的新手 不要直接google搜索 hugo搭建博客 因为有的时候 在别人那行得通 但是到自己这里不行 就会怀疑自己的能力，是不是自己太辣鸡，其实是有的时候写博客，只是为了自己记录一下，可能把有些步骤给省略了，但是官网不会啊，官网就是想让你都能完成，都来使用，所以步骤都会写的很清楚，所以我先把**官网**放在链接里，大家通过查阅文档，有问题了再来看我的博客，这样学习起来，自己的印象也会比较深。
​	odk，废话不多说，我开始啦！（我的环境是macOS）
No1 下载Hugo mac推荐是用homebrew 我后面会写homebrew的教程 这里先欠着哈  brew install hugo //使用brew下载hugo hugo version	//查看hugo版本 确定是否下载成功 看到这个就代表你成功下载了Hugo!!! 🎉🎉🎉
No2 Hugo 创建一个博客 hugo new site xxx //xxx 是你文件的名字 hugo new site keda725.github.io 你就会发现Hugo在当前路径下创建了一个keda725.github.io的文件夹，可以看到Hugo为我们创建了一些文件，themes，date，static等。
|- archetypes ：存放default.md，头文件格式 |- content ：content目录存放博客文章（markdown文件） |- data ：存放自定义模版，导入的toml文件（或json，yaml） |- layouts ：layouts目录存放的是网站的模板文件 |- static ：static目录存放图片，css等静态资源 |- themes ：存放网站主题文件 |- config.</description>
            <content type="html"><![CDATA[<h4 id="为什么选择hugo">为什么选择hugo?</h4>
<hr>
<p>​		因为也是刚刚开始搭建自己的博客，看了<a href="https://space.bilibili.com/384068749/">CodeSheep</a>程序羊老哥以前介绍的hugo，是基于go语言写的，特点就是快，也符合我们当代年轻人的特点(😁)，另外就是搭建起来也很方便 简单几个命令，就可以看到成果，不至于半途而废。(另外google了一下为什么选择hugo？看看别人是怎么说的 机灵鬼.gif)</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/hugo%E5%AE%98%E7%BD%91%E6%88%AA%E5%9B%BE.png" alt="hugo官网截图"></p>
<p>​		第一点得提的就是Hugo 打出的标语 &ndash; “The world’s fastest framework for building websites”。Hugo 依靠Go语言进行开发，号称世界上最快的构建网站工具，到底有多快？根据相关博主提供的数据，他200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。就我个人的体验来说，Hugo确实大大加快了网页生成的速度，平常增加一篇博文然后再生成渲染需要4秒左右，而Hugo基本上是1秒内完成。正是依赖于Hugo 快速生成的特点，调试方便成了Hugo的第二大特点。基本上我在源文件处修改的内容可以实时地显示在网页上，而不用再次敲代码生成再预览，这对于博主来说简直就是一个福音。</p>
<p><strong><a href="https://sspai.com/post/59904">放个链接 看看能不能说服你？</a></strong></p>
<h4 id="hugo从0到1">hugo从0到1</h4>
<hr>
<p>​		我建议和我一样的新手 不要直接google搜索 hugo搭建博客 因为有的时候 在别人那行得通 但是到自己这里不行 就会怀疑自己的能力，是不是自己太辣鸡，其实是有的时候写博客，只是为了自己记录一下，可能把有些步骤给省略了，但是官网不会啊，官网就是想让你都能完成，都来使用，所以步骤都会写的很清楚，所以我先把**<a href="https://gohugo.io/getting-started/quick-start/">官网</a>**放在链接里，大家通过查阅文档，有问题了再来看我的博客，这样学习起来，自己的印象也会比较深。</p>
<p>​		odk，废话不多说，我开始啦！（我的环境是macOS）</p>
<h5 id="no1-下载hugo-mac推荐是用homebrew-我后面会写homebrew的教程-这里先欠着哈">No1 下载Hugo mac推荐是用homebrew 我后面会写homebrew的教程 这里先欠着哈</h5>
<hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">brew install hugo   //使用brew下载hugo
hugo version				//查看hugo版本 确定是否下载成功
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/version.png" alt=""></p>
<p>看到这个就代表你成功下载了Hugo!!! 🎉🎉🎉</p>
<h5 id="no2-hugo-创建一个博客">No2 Hugo 创建一个博客</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo new site xxx  //xxx 是你文件的名字

hugo new site keda725.github.io
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/newsite.png" alt=""></p>
<p>你就会发现Hugo在当前路径下创建了一个keda725.github.io的文件夹，可以看到Hugo为我们创建了一些文件，themes，date，static等。</p>
<p>|- archetypes ：存放default.md，头文件格式
|- content ：content目录存放博客文章（markdown文件）
|- data ：存放自定义模版，导入的toml文件（或json，yaml）
|- layouts ：layouts目录存放的是网站的模板文件
|- static ：static目录存放图片，css等静态资源
|- themes ：存放网站主题文件
|- config.toml ：config.toml是网站的配置文件</p>
<h5 id="no3-选择一个主题">No3 选择一个主题</h5>
<hr>
<p>强烈推荐<a href="https://themes.gohugo.io/hugo-theme-hello-friend-ng/">hello-friend-ng</a>这个主题，自认为是很赞的一个主题，当然看大家自己的选择喽，我下面的介绍以及图片问题的处理，都是根据这个主题来介绍的。</p>
<p>注意，从现在开始到动作都是在keda725.github.io这个路径下的操作了，不要在～下面搞，还要复制粘贴一道，浪费时间！</p>
<p>git的安装和使用 这里就先不说了，先放一个官方的<a href="https://git-scm.com/">文档链接</a>！</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">git clone https<span style="color:#960050;background-color:#1e0010">:</span>//github.com/rhazdon/hugo-theme-hello-friend-ng.git themes/hello-friend-ng 
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/theme.png" alt=""></p>
<p>这就说明主题下载成功啦 我们先启动一下hugo 看看效果，让自己也有点成就感！</p>
<h5 id="no4-启动hugo">No4 启动Hugo</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo server -t hello-friend-ng -D 
</code></pre></div><ul>
<li>-t是&ndash;theme的缩写 声明主题是hello-friend-ng</li>
<li>-D是&ndash;buildDrafts的缩写  连草稿一同展示出来</li>
</ul>
<p>也可以在执行这一步之前把theme写入到config.toml中</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">echo <span style="color:#e6db74">&#39;theme = &#34;hello-friend-ng &#34;&#39;</span> &gt;&gt; config.toml
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/server.png" alt="server"></p>
<p>然后在网址上输入http://localhost:1313/就可以看到在本地启动的hugo博客啦！</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/hello.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/hello2.png" alt=""></p>
<p>这个主题有白天和黑夜两种模式可以选择，默认是黑色的。</p>
<p>做到这里我们只是把选择了一个主题和成功启动了hugo，那么接下来我们就开始一下我们的博客编写和配置啦！</p>
<h5 id="no5-写一篇博客">No5 写一篇博客</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo new posts/第一篇博客.md
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2.png" alt=""></p>
<p>然后我们按住键盘的command win上应该是control 鼠标放在第一篇博客上 打开这个md文件</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%8D%9A%E5%AE%A2.png" alt="博客"></p>
<p>随便写两句 慢慢来！</p>
<h5 id="no6-再次启动hugo">No6 再次启动hugo</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">hugo server -t hello-friend-ng -D
</code></pre></div><p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%86%8D%E6%AC%A1%E5%90%AF%E5%8A%A8.png" alt=""></p>
<p>发现并没有文章发不上来，不要慌，这是因为我们针对这个主题还没有配置主菜单。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">cd themes/hello-friend-ng/exampleSite/
</code></pre></div><p>打开config.toml 可以用vscode 或者vim  添加如下内容后保存，然后把这个config.toml拷贝一份放在keda725.github.io文件夹下替换原有的config.toml</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-toml" data-lang="toml">[[<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">main</span>]]
   <span style="color:#a6e22e">identifier</span> = <span style="color:#e6db74">&#34;blog&#34;</span>
   <span style="color:#a6e22e">name</span>       = <span style="color:#e6db74">&#34;Blogs&#34;</span>
   <span style="color:#a6e22e">url</span>        = <span style="color:#e6db74">&#34;/posts&#34;</span>

 [[<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">main</span>]]
   <span style="color:#a6e22e">identifier</span> = <span style="color:#e6db74">&#34;categories&#34;</span>
   <span style="color:#a6e22e">name</span>       = <span style="color:#e6db74">&#34;Categories&#34;</span>
   <span style="color:#a6e22e">url</span>        = <span style="color:#e6db74">&#34;/categories/&#34;</span>

 [[<span style="color:#a6e22e">menu</span>.<span style="color:#a6e22e">main</span>]]
   <span style="color:#a6e22e">identifier</span> = <span style="color:#e6db74">&#34;tags&#34;</span>
   <span style="color:#a6e22e">name</span>       = <span style="color:#e6db74">&#34;Tags&#34;</span>
   <span style="color:#a6e22e">url</span>        = <span style="color:#e6db74">&#34;/tags/&#34;</span>

</code></pre></div><p>然后重新启动hugo server</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E9%85%8D%E7%BD%AE%E5%90%8E.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E9%85%8D%E7%BD%AE%E5%90%8E2.png" alt=""></p>
<h3 id="如果想要插入图片在typora中是这样的">如果想要插入图片，在Typora中是这样的：</h3>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%871.png" alt="插入图片2"></p>
<p>我不知道我讲清楚没有 如有问题 可以加我微信TSKB1996</p>
<h4 id="将博客部署在github上">将博客部署在GitHub上</h4>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E5%92%8Cgithub%E5%85%B3%E8%81%94.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E7%94%9F%E6%88%90public%E6%96%87%E4%BB%B6.png" alt="生成public文件"></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/gitinit.png" alt="gitinit"></p>
<p>初始化仓库的时候是在public上 我们上传的只是public这个文件夹</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">git init
git remote add origin https<span style="color:#960050;background-color:#1e0010">:</span>//github.com/xxx/xxx.github.io.git //你的github名
git commit -m <span style="color:#e6db74">&#34;xxx&#34;</span>  //你提交的信息
git push -u origin master
</code></pre></div><hr>
<p>这就是所有的内容啦！！🎉🎉🎉</p>
<p>剩余的一些个性化设置 就由你自己来完成啦！</p>
<p>如果你还有问题 欢迎添加我的微信 或者你觉得我写的不错想请我喝杯茶🍵</p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E4%BA%8C%E7%BB%B4%E7%A0%811.png" alt=""></p>
<p><img src="/img/hugo%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E5%8F%8A%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/%E4%BA%8C%E7%BB%B4%E7%A0%812.png" alt=""></p>
]]></content>
        </item>
        
    </channel>
</rss>
